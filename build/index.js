var W="CheckpointLoaderSimple",Y="LoraLoader",z="KSampler";class Z extends EventTarget{apiHost;apiBase;clientId;socket=null;registered=new Set;static generateId(){return Math.random().toString(36).substr(2,9)+Math.random().toString(36).substr(2,9)}on(h,r,K){this.addEventListener(h,r,K)}off(h,r,K){this.removeEventListener(h,r,K)}get id(){return this.clientId??this.apiBase}constructor(h,r=Z.generateId()){super();return this.apiHost=h,this.apiBase=h.split("://")[1],this.clientId=r,this}apiURL(h){return`${this.apiHost}${h}`}async fetchApi(h,r){if(!r)r={};if(!r.headers)r.headers={};return r.headers["Comfy-User"]=this.clientId||"",fetch(this.apiURL(h),r)}async pollStatus(){return(await this.fetchApi("/prompt")).json()}async queuePrompt(h,r){const K={client_id:this.clientId,prompt:r};if(h===-1)K.front=!0;else if(h!==0)K.number=h;try{const y=await this.fetchApi("/prompt",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(K)});if(y.status!==200)throw{response:await y.json()};return y.json()}catch(y){return console.warn("Can't queue prompt",r,y),!1}}async getQueue(){return(await this.fetchApi("/queue")).json()}async getHistories(h=200){return(await this.fetchApi(`/history?max_items=${h}`)).json()}async getHistory(h){return(await(await this.fetchApi(`/history/${h}`)).json())[h]}async getSystemStats(){return(await this.fetchApi("/system_stats")).json()}async getExtensions(){return(await this.fetchApi("/extensions")).json()}async getEmbeddings(){return(await this.fetchApi("/embeddings")).json()}async getCheckpoints(){return(await this.getNodeDefs(W))[W].input.required?.ckpt_name?.[0]??[]}async getLoras(){return(await this.getNodeDefs(Y))[Y].input.required?.lora_name?.[0]??[]}async getSamplerInfo(){const h=await this.getNodeDefs(z);return{sampler:h[z].input.required.sampler_name??[],scheduler:h[z].input.required.scheduler??[]}}async getNodeDefs(h){return(await this.fetchApi(`/object_info/${h??""}`)).json()}async getUserConfig(){return(await this.fetchApi("/users")).json()}async createUser(h){return await this.fetchApi("/users",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:h})})}async getSettings(){return(await this.fetchApi("/settings")).json()}async getSetting(h){return(await this.fetchApi(`/settings/${encodeURIComponent(h)}`)).json()}async storeSettings(h){await this.fetchApi("/settings",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(h)})}async storeSetting(h,r){await this.fetchApi(`/settings/${encodeURIComponent(h)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)})}async uploadImage(h,r,K){const y=new FormData;if(h instanceof Buffer)y.append("image",new Blob([h]),r);else y.append("image",h,r);y.append("subfolder",K?.subfolder??""),y.append("overwrite",K?.override?.toString()??"false");try{const T=await(await this.fetchApi("/upload/image",{method:"POST",body:y})).json(),J={...T,filename:T.name};return{info:J,url:this.getPathImage(J)}}catch(P){return console.warn(P),!1}}getPathImage(h){return this.apiURL(`/view?filename=${h.filename}&type=${h.type}&subfolder=${h.subfolder??""}`)}async getUserData(h){return this.fetchApi(`/userdata/${encodeURIComponent(h)}`)}async storeUserData(h,r,K={overwrite:!0,stringify:!0,throwOnError:!0}){const y=await this.fetchApi(`/userdata/${encodeURIComponent(h)}?overwrite=${K.overwrite}`,{method:"POST",headers:{"Content-Type":K.stringify?"application/json":"application/octet-stream"},body:K.stringify?JSON.stringify(r):r,...K});if(y.status!==200&&K.throwOnError!==!1)throw new Error(`Error storing user data file '${h}': ${y.status} ${y.statusText}`);return y}async deleteUserData(h){const r=await this.fetchApi(`/userdata/${encodeURIComponent(h)}`,{method:"DELETE"});if(r.status!==204)throw new Error(`Error removing user data file '${h}': ${r.status} ${r.statusText}`)}async moveUserData(h,r,K={overwrite:!1}){return this.fetchApi(`/userdata/${encodeURIComponent(h)}/move/${encodeURIComponent(r)}?overwrite=${K.overwrite}`,{method:"POST"})}async listUserData(h,r,K){const y=await this.fetchApi(`/userdata?${new URLSearchParams({dir:h,recurse:r?.toString()??"",split:K?.toString()??""})}`);if(y.status===404)return[];if(y.status!==200)throw new Error(`Error getting user data list '${h}': ${y.status} ${y.statusText}`);return y.json()}async interrupt(){await this.fetchApi("/interrupt",{method:"POST"})}init(){return this.createSocket(),this}createSocket(h=!1){if(this.socket)return;let r=!1,K="?clientId="+this.clientId;this.socket=new WebSocket(`ws${this.apiHost.includes("https:")?"s":""}://${this.apiBase}/ws${K}`),this.socket.binaryType="arraybuffer",this.socket.addEventListener("open",()=>{if(r=!0,h)this.dispatchEvent(new CustomEvent("reconnected"))}),this.socket.addEventListener("error",()=>{if(this.socket)this.socket.close();if(!h&&!r)this.pollQueue()}),this.socket.addEventListener("close",()=>{if(setTimeout(()=>{this.socket=null,this.createSocket(!0)},300),r)this.dispatchEvent(new CustomEvent("status",{detail:null})),this.dispatchEvent(new CustomEvent("reconnecting"))}),this.socket.addEventListener("message",(y)=>{try{if(y.data instanceof ArrayBuffer){const T=new DataView(y.data).getUint32(0),J=y.data.slice(4);switch(T){case 1:const $=new DataView(y.data).getUint32(0);let O;switch($){case 1:default:O="image/jpeg";break;case 2:O="image/png"}const U=new Blob([J.slice(4)],{type:O});this.dispatchEvent(new CustomEvent("b_preview",{detail:U}));break;default:throw new Error(`Unknown binary websocket message of type ${T}`)}}else{const P=JSON.parse(y.data);if(P.type!=="crystools.monitor")this.dispatchEvent(new CustomEvent("all",{detail:P}));switch(P.type){case"status":if(P.data.sid)this.clientId=P.data.sid;this.dispatchEvent(new CustomEvent("status",{detail:P.data.status}));break;case"progress":this.dispatchEvent(new CustomEvent("progress",{detail:P.data}));break;case"executing":this.dispatchEvent(new CustomEvent("executing",{detail:P.data.node}));break;case"executed":this.dispatchEvent(new CustomEvent("executed",{detail:P.data}));break;case"execution_start":this.dispatchEvent(new CustomEvent("execution_start",{detail:P.data}));break;case"execution_error":this.dispatchEvent(new CustomEvent("execution_error",{detail:P.data}));break;case"execution_cached":this.dispatchEvent(new CustomEvent("execution_cached",{detail:P.data}));break;case"crystools.monitor":this.dispatchEvent(new CustomEvent("crystools.monitor",{detail:P.data}));break;default:if(this.registered.has(P.type))this.dispatchEvent(new CustomEvent(P.type,{detail:P.data}));else console.warn("Unhandled event from server",P.type,P.data)}}}catch(P){console.warn("Unhandled message:",y.data,P)}})}pollQueue(){setInterval(async()=>{try{const r=await(await this.fetchApi("/prompt")).json();this.dispatchEvent(new CustomEvent("status",{detail:r}))}catch(h){this.dispatchEvent(new CustomEvent("status",{detail:null}))}},1000)}}class R{client;prompt;started=!1;onPreviewFn;onStartFn;onFinishedFn;onFailedFn;onProgressFn;constructor(h,r){return this.client=h,this.prompt=r,this}onPreview(h){return this.onPreviewFn=h,this}onStart(h){return this.onStartFn=h,this}onFinished(h){return this.onFinishedFn=h,this}onFailed(h){return this.onFailedFn=h,this}onProgress(h){return this.onProgressFn=h,this}async run(){const h=await this.client.queuePrompt(-1,this.prompt.workflow);if(h){const r=this.prompt.mapOutputKeys,K=Object.entries(r).reduce((O,[U,B])=>{if(B)O[B]=U;return O},{}),{prompt_id:y}=h,P={},T=await this.client.getHistory(y);if(T?.status?.completed){const O=T.outputs;for(let U in r){const B=r[U];if(B)P[U]=O[B]}return this.onFinishedFn?.(P),P}const J=(O)=>{if(O.detail.prompt_id===y&&!this.started)this.started=!0,this.onStartFn?.();this.onProgressFn?.(O.detail)},C=(O)=>{if(this.onPreviewFn)this.onPreviewFn(O.detail)};this.client.on("progress",J),this.client.on("b_preview",C);let $=Object.keys(K).length;return new Promise((O)=>{const U=(G)=>{const V=G.detail;if(V.prompt_id!==y)return;const x=V.node;if(K[x]){const H=K[x];if(H)P[H]=V.output;$--}if($===0)this.client.off("progress",J),this.client.off("executed",U),this.client.off("b_preview",C),this.onFinishedFn?.(P),O(P)};this.client.on("executed",U);const B=(G)=>{if(G.detail.prompt_id!==y)return;this.client.off("progress",J),this.client.off("executed",U),this.client.off("b_preview",C),this.client.off("execution_error",B),this.onFailedFn?.(),O(!1)};this.client.on("execution_error",B)})}}}var q=(h)=>new Promise((r)=>setTimeout(r,h));class S{clients;queueInfo=[];pickingInfo=[];mode=0;jobQueue=[];routineIdx=0;picking=!1;constructor(h,r=0){this.clients=h;for(let K=0;K<h.length;K++)this.queueInfo.push(0),this.pickingInfo.push(!1),this.clients[K].on("status",(y)=>{if(this.queueInfo[K]=y.detail.exec_info.queue_remaining,this.queueInfo[K]>0)this.pickingInfo[K]=!1}),this.clients[K].init();return this.mode=r,this}addClient(h){this.clients.push(h),this.queueInfo.push(0);const r=this.clients.length-1;this.clients[r].on("status",(K)=>{this.queueInfo[r]=K.detail.exec_info.queue_remaining})}removeClient(h){const r=this.clients.indexOf(h);if(r!==-1)this.clients.splice(r,1),this.queueInfo.splice(r,1)}claim(h){this.jobQueue.push(h),this.pickJob()}run(h){return new Promise((r,K)=>{this.claim(async(y)=>{try{r(await h(y))}catch(P){console.error(P),K(P)}})})}batch(h){const r=h.map((K)=>{return this.run(K)});return Promise.all(r)}async getAvailableClient(){switch(this.mode){case 0:{let h=-1;while(h===-1)if(h=this.queueInfo.findIndex((r,K)=>{if(r===0&&!this.pickingInfo[K])return!0;return!1}),h===-1)await q(50);return this.queueInfo[h]=1,this.pickingInfo[h]=!0,this.clients[h]}case 1:{let h=-1,r=Number.MAX_SAFE_INTEGER;for(let K=0;K<this.queueInfo.length;K++)if(this.queueInfo[K]<r)r=this.queueInfo[K],h=K;return this.queueInfo[h]=1,this.clients[h]}case 2:{const h=this.routineIdx;return this.routineIdx=(this.routineIdx+1)%this.clients.length,this.clients[h]}}}async pickJob(){if(this.picking)return;if(this.jobQueue.length===0)return;const h=this.jobQueue.shift();this.picking=!0;const r=await this.getAvailableClient();h?.(r),this.picking=!1,this.pickJob()}}class j{prompt;mapInputPath;mapOutputPath;constructor(h,r,K){return this.prompt=JSON.parse(JSON.stringify(h)),this.mapInputPath=r,this.mapOutputPath=K,this}input(h,r){const K=this.mapInputPath[h];if(!K)throw new Error(`Key ${h} not found`);const y=K.split(".");let P=this.prompt;for(let T=0;T<y.length-1;T++)P=P[y[T]];return P[y[y.length-1]]=r,this}get mapOutputKeys(){return this.mapOutputPath}get mapInputKeys(){return this.mapOutputPath}get workflow(){return this.prompt}}class L{prompt;mapInputKeys={};mapOutputKeys={};constructor(h,r,K){return this.prompt=h,r.forEach((y)=>{this.mapInputKeys[y]=void 0}),K.forEach((y)=>{this.mapOutputKeys[y]=void 0}),this}setInputNode(h,r){return this.mapInputKeys[h]=r,this}setOutputNode(h,r){return this.mapOutputKeys[h]=r,this}get caller(){return new j(this.prompt,this.mapInputKeys,this.mapOutputKeys)}}export{j as PromptCaller,L as PromptBuilder,S as ComfyPool,Z as ComfyApi,R as CallWrapper};

//# debugId=9BB9C064189B9A9864756E2164756E21
