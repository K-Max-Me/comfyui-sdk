// Generated by dts-bundle-generator v9.5.1

export interface HistoryResponse {
	[key: string]: HistoryEntry;
}
export interface HistoryEntry {
	prompt: PromptData;
	outputs: OutputData;
	status: StatusData;
}
export interface PromptData {
	[index: number]: number | string | NodeData | MetadataData;
}
export interface NodeData {
	[key: string]: {
		inputs: {
			[key: string]: any;
		};
		class_type: string;
		_meta: {
			title: string;
		};
	};
}
export interface MetadataData {
	[key: string]: any;
}
export interface ImageInfo {
	filename: string;
	subfolder: string;
	type: string;
}
export interface OutputData {
	[key: string]: {
		width?: number[];
		height?: number[];
		ratio?: number[];
		images?: ImageInfo[];
	};
}
export interface StatusData {
	status_str: string;
	completed: boolean;
	messages: [
		string,
		{
			[key: string]: any;
		}
	][];
}
export interface QueueResponse {
	queue_running: QueueItem[];
	queue_pending: QueueItem[];
}
export interface QueueItem {
	[index: number]: number | string | NodeData | MetadataData;
}
export interface NodeData {
	[key: string]: {
		inputs: {
			[key: string]: any;
		};
		class_type: string;
		_meta: {
			title: string;
		};
	};
}
export interface MetadataData {
	[key: string]: any;
}
export interface QueuePromptResponse {
	prompt_id: string;
	number: number;
	node_errors: {
		[key: string]: any;
	};
}
export interface SystemStatsResponse {
	system: {
		os: string;
		python_version: string;
		embedded_python: boolean;
	};
	devices: DeviceStats[];
}
export interface DeviceStats {
	name: string;
	type: string;
	index: number;
	vram_total: number;
	vram_free: number;
	torch_vram_total: number;
	torch_vram_free: number;
}
export interface QueueStatus {
	exec_info: {
		queue_remaining: number;
	};
}
export interface NodeDefsResponse {
	[key: string]: NodeDef;
}
export interface NodeDef {
	input: {
		required: {
			[key: string]: any;
		};
	};
	output: string[];
	output_is_list: boolean[];
	output_name: string[];
	name: string;
	display_name: string;
	description: string;
	category: string;
	output_node: boolean;
}
export interface NodeProgress {
	value: number;
	max: number;
	prompt_id: string;
	node: string;
}
export type TEventKey = "all" | "status" | "progress" | "executing" | "executed" | "execution_start" | "execution_error" | "execution_cached" | "crystools.monitor" | "reconnected" | "reconnecting" | "b_preview";
export declare class ComfyApi extends EventTarget {
	private apiHost;
	private apiBase;
	private clientId;
	private socket;
	private registered;
	static generateId(): string;
	on(type: TEventKey, callback: (event: CustomEvent) => void, options?: AddEventListenerOptions | boolean): void;
	off(type: TEventKey, callback: (event: CustomEvent) => void, options?: EventListenerOptions | boolean): void;
	get id(): string;
	constructor(host: string, clientId?: string);
	private apiURL;
	private fetchApi;
	/**
	 * Polls the status for colab and other things that don't support websockets.
	 * @returns {Promise<QueueStatus>} The status information.
	 */
	pollStatus(): Promise<QueueStatus>;
	/**
	 * Queues a prompt for processing.
	 * @param {number} number The index at which to queue the prompt.
	 * @param {object} workflow Additional workflow data.
	 * @returns {Promise<QueuePromptResponse>} The response from the API.
	 */
	queuePrompt(number: number, workflow: object): Promise<QueuePromptResponse | false>;
	/**
	 * Retrieves the current state of the queue.
	 * @returns {Promise<QueueResponse>} The queue state.
	 */
	getQueue(): Promise<QueueResponse>;
	/**
	 * Retrieves the prompt execution history.
	 * @param {number} [maxItems=200] The maximum number of items to retrieve.
	 * @returns {Promise<HistoryResponse>} The prompt execution history.
	 */
	getHistories(maxItems?: number): Promise<HistoryResponse>;
	/**
	 * Retrieves the history entry for a given prompt ID.
	 * @param promptId - The ID of the prompt.
	 * @returns A Promise that resolves to the HistoryEntry object.
	 */
	getHistory(promptId: string): Promise<HistoryEntry | undefined>;
	/**
	 * Retrieves system and device stats.
	 * @returns {Promise<SystemStatsResponse>} The system stats.
	 */
	getSystemStats(): Promise<SystemStatsResponse>;
	/**
	 * Retrieves a list of extension URLs.
	 * @returns {Promise<string[]>} A list of extension URLs.
	 */
	getExtensions(): Promise<string[]>;
	/**
	 * Retrieves a list of embedding names.
	 * @returns {Promise<string[]>} A list of embedding names.
	 */
	getEmbeddings(): Promise<string[]>;
	/**
	 * Retrieves the checkpoints from the server.
	 * @returns A promise that resolves to an array of strings representing the checkpoints.
	 */
	getCheckpoints(): Promise<string[]>;
	/**
	 * Retrieves the Loras from the node definitions.
	 * @returns A Promise that resolves to an array of strings representing the Loras.
	 */
	getLoras(): Promise<string[]>;
	/**
	 * Retrieves the sampler information.
	 * @returns An object containing the sampler and scheduler information.
	 */
	getSamplerInfo(): Promise<{
		sampler: any;
		scheduler: any;
	}>;
	/**
	 * Retrieves node object definitions for the graph.
	 * @returns {Promise<NodeDefsResponse>} The node definitions.
	 */
	getNodeDefs(nodeName?: string): Promise<NodeDefsResponse>;
	/**
	 * Retrieves user configuration data.
	 * @returns {Promise<any>} The user configuration data.
	 */
	getUserConfig(): Promise<any>;
	/**
	 * Creates a new user.
	 * @param {string} username The username of the new user.
	 * @returns {Promise<Response>} The response from the API.
	 */
	createUser(username: string): Promise<Response>;
	/**
	 * Retrieves all setting values for the current user.
	 * @returns {Promise<any>} A dictionary of setting id to value.
	 */
	getSettings(): Promise<any>;
	/**
	 * Retrieves a specific setting for the current user.
	 * @param {string} id The id of the setting to fetch.
	 * @returns {Promise<any>} The setting value.
	 */
	getSetting(id: string): Promise<any>;
	/**
	 * Stores a dictionary of settings for the current user.
	 * @param {Record<string, unknown>} settings Dictionary of setting id to value to save.
	 * @returns {Promise<void>}
	 */
	storeSettings(settings: Record<string, unknown>): Promise<void>;
	/**
	 * Stores a specific setting for the current user.
	 * @param {string} id The id of the setting to update.
	 * @param {unknown} value The value of the setting.
	 * @returns {Promise<void>}
	 */
	storeSetting(id: string, value: unknown): Promise<void>;
	/**
	 * Uploads an image file to the server.
	 * @param file - The image file to upload.
	 * @param fileName - The name of the image file.
	 * @param override - Optional. Specifies whether to override an existing file with the same name. Default is true.
	 * @returns A Promise that resolves to an object containing the image information and the URL of the uploaded image,
	 *          or false if the upload fails.
	 */
	uploadImage(file: Buffer | Blob, fileName: string, config?: {
		override?: boolean;
		subfolder?: string;
	}): Promise<{
		info: ImageInfo;
		url: string;
	} | false>;
	/**
	 * Returns the path to an image based on the provided image information.
	 * @param imageInfo - The information of the image.
	 * @returns The path to the image.
	 */
	getPathImage(imageInfo: ImageInfo): string;
	/**
	 * Retrieves a user data file for the current user.
	 * @param {string} file The name of the userdata file to load.
	 * @returns {Promise<Response>} The fetch response object.
	 */
	getUserData(file: string): Promise<Response>;
	/**
	 * Stores a user data file for the current user.
	 * @param {string} file The name of the userdata file to save.
	 * @param {unknown} data The data to save to the file.
	 * @param {RequestInit & { overwrite?: boolean, stringify?: boolean, throwOnError?: boolean }} [options] Additional options for storing the file.
	 * @returns {Promise<Response>}
	 */
	storeUserData(file: string, data: unknown, options?: RequestInit & {
		overwrite?: boolean;
		stringify?: boolean;
		throwOnError?: boolean;
	}): Promise<Response>;
	/**
	 * Deletes a user data file for the current user.
	 * @param {string} file The name of the userdata file to delete.
	 * @returns {Promise<void>}
	 */
	deleteUserData(file: string): Promise<void>;
	/**
	 * Moves a user data file for the current user.
	 * @param {string} source The userdata file to move.
	 * @param {string} dest The destination for the file.
	 * @param {RequestInit & { overwrite?: boolean }} [options] Additional options for moving the file.
	 * @returns {Promise<Response>}
	 */
	moveUserData(source: string, dest: string, options?: RequestInit & {
		overwrite?: boolean;
	}): Promise<Response>;
	/**
	 * Lists user data files for the current user.
	 * @param {string} dir The directory in which to list files.
	 * @param {boolean} [recurse] If the listing should be recursive.
	 * @param {boolean} [split] If the paths should be split based on the OS path separator.
	 * @returns {Promise<string[]>} The list of files.
	 */
	listUserData(dir: string, recurse?: boolean, split?: boolean): Promise<string[]>;
	/**
	 * Interrupts the execution of the running prompt.
	 * @returns {Promise<void>}
	 */
	interrupt(): Promise<void>;
	/**
	 * Initializes the WebSocket for real-time updates.
	 */
	init(): this;
	/**
	 * Creates and connects a WebSocket for real-time updates.
	 * @param {boolean} isReconnect If the socket connection is a reconnect attempt.
	 */
	private createSocket;
	/**
	 * Polls the status queue for updates.
	 * Used for environments that do not support WebSockets.
	 */
	private pollQueue;
}
export type KeysUnion<T, Cache extends string = ""> = 
/**
 * If T is no more an object, it means that this call
 * is last in a recursion, hence we need to return
 * our Cache (accumulator)
 */
T extends PropertyKey ? Cache : {
	[P in keyof T]: P extends string ? Cache extends "" ? KeysUnion<T[P], `${P}`> : /**
	   * Since Cache is not empty, we need to unionize it with property
	   * and call KeysUnion recursively again,
	   * In such way every iteration we apply to Cache new property with dot
	   */ Cache | KeysUnion<T[P], `${Cache}.${P}`> : never;
}[keyof T];
export declare class PromptCaller<I extends string = "", O extends string = ""> {
	prompt: object;
	mapInputPath: Record<I, string | undefined>;
	mapOutputPath: Record<O, string | undefined>;
	constructor(prompt: object, mapIn: Record<string, string | undefined>, mapOut: Record<string, string | undefined>);
	input<T = string | number>(key: I, value: T): this;
	get mapOutputKeys(): Record<O, string | undefined>;
	get mapInputKeys(): Record<O, string | undefined>;
	get workflow(): object;
}
export declare class PromptBuilder<I extends string, O extends string, T = object> {
	prompt: T;
	mapInputKeys: Record<I, KeysUnion<T> | undefined>;
	mapOutputKeys: Record<O, KeysUnion<T> | undefined>;
	constructor(prompt: T, inputKeys: I[], outputKeys: O[]);
	setInputNode(input: I, key: KeysUnion<T>): this;
	setOutputNode(output: O, key: KeysUnion<T>): this;
	get caller(): PromptCaller<I, O>;
}
export declare class CallWrapper<T extends PromptCaller<string, string>> {
	private client;
	private prompt;
	private started;
	private onPreviewFn?;
	private onStartFn?;
	private onFinishedFn?;
	private onFailedFn?;
	private onProgressFn?;
	constructor(client: ComfyApi, workflow: T);
	onPreview(fn: (ev: Blob) => void): this;
	onStart(fn: () => void): this;
	onFinished(fn: (data: Record<keyof T["mapOutputPath"], any>) => void): this;
	onFailed(fn: () => void): this;
	onProgress(fn: (info: NodeProgress) => void): this;
	run(): Promise<Record<keyof T["mapOutputPath"], any> | undefined | false>;
}
declare enum EQueueMode {
	/**
	 * Picks the client which has zero queue remaining. This is the default mode. (For who using along with ComfyUI web interface)
	 */
	"PICK_ZERO" = 0,
	/**
	 * Picks the client which has the lowest queue remaining.
	 */
	"PICK_LOWEST" = 1,
	/**
	 * Picks the client in a round-robin manner.
	 */
	"PICK_ROUTINE" = 2
}
export declare class ComfyPool {
	clients: ComfyApi[];
	queueInfo: number[];
	pickingInfo: boolean[];
	mode: EQueueMode;
	jobQueue: ((api: ComfyApi) => Promise<void>)[];
	/**
	 * This is for PICK_ROUTINE mode
	 */
	routineIdx: number;
	picking: boolean;
	/**
	 * Represents a pool of ComfyApi clients.
	 * @param clients - An array of ComfyApi instances.
	 * @param mode - The queue mode for the pool. Defaults to "PICK_ZERO".
	 */
	constructor(clients: ComfyApi[], mode?: EQueueMode);
	addClient(client: ComfyApi): void;
	removeClient(client: ComfyApi): void;
	private claim;
	/**
	 * Run a task on the pool.
	 */
	run<T>(claim: (client: ComfyApi) => Promise<T>): Promise<T>;
	/**
	 * Run a batch of tasks on the pool.
	 */
	batch<T>(claims: ((client: ComfyApi) => Promise<T>)[]): Promise<Awaited<T>[]>;
	private getAvailableClient;
	private pickJob;
}
export type TSamplerName = "euler" | "euler_cfg_pp" | "euler_ancestral" | "euler_ancestral_cfg_pp" | "heun" | "heunpp2" | "dpm_2" | "dpm_2_ancestral" | "lms" | "dpm_fast" | "dpm_adaptive" | "dpmpp_2s_ancestral" | "dpmpp_sde" | "dpmpp_sde_gpu" | "dpmpp_2m" | "dpmpp_2m_sde" | "dpmpp_2m_sde_gpu" | "dpmpp_3m_sde" | "dpmpp_3m_sde_gpu" | "ddpm" | "lcm" | "ipndm" | "ipndm_v" | "deis" | "ddim" | "uni_pc" | "uni_pc_bh2";
export type TSchedulerName = "normal" | "karras" | "exponential" | "sgm_uniform" | "simple" | "ddim_uniform";

export {};
