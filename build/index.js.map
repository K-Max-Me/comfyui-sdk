{
  "version": 3,
  "sources": ["../src/contansts.ts", "../src/client.ts", "../src/call-wrapper.ts", "../src/tools.ts", "../src/pool.ts", "../src/prompt-builder.ts"],
  "sourcesContent": [
    "export const LOAD_CHECKPOINTS_EXTENSION = \"CheckpointLoaderSimple\";\nexport const LOAD_LORAS_EXTENSION = \"LoraLoader\";\nexport const LOAD_KSAMPLER_EXTENSION = \"KSampler\";\n",
    "import type {\n  HistoryEntry,\n  HistoryResponse,\n  ImageInfo,\n  NodeDefsResponse,\n  QueuePromptResponse,\n  QueueResponse,\n  QueueStatus,\n  SystemStatsResponse,\n} from \"../types/api\";\n\nimport {\n  LOAD_CHECKPOINTS_EXTENSION,\n  LOAD_KSAMPLER_EXTENSION,\n  LOAD_LORAS_EXTENSION,\n} from \"./contansts\";\n\ninterface FetchOptions extends RequestInit {\n  headers?: {\n    [key: string]: string;\n  };\n}\n\ntype TEventKey =\n  | \"all\"\n  | \"status\"\n  | \"progress\"\n  | \"executing\"\n  | \"executed\"\n  | \"execution_start\"\n  | \"execution_error\"\n  | \"execution_cached\"\n  | \"crystools.monitor\"\n  | \"reconnected\"\n  | \"reconnecting\"\n  | \"b_preview\";\n\nexport class ComfyApi extends EventTarget {\n  private apiHost: string;\n  private apiBase: string;\n  private clientId: string | null;\n  private socket: WebSocket | null = null;\n  private registered: Set<string> = new Set();\n\n  static generateId(): string {\n    return (\n      Math.random().toString(36).substr(2, 9) +\n      Math.random().toString(36).substr(2, 9)\n    );\n  }\n\n  public on(\n    type: TEventKey,\n    callback: (event: CustomEvent) => void,\n    options?: AddEventListenerOptions | boolean\n  ): void {\n    this.addEventListener(type, callback as any, options);\n  }\n\n  public off(\n    type: TEventKey,\n    callback: (event: CustomEvent) => void,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this.removeEventListener(type, callback as any, options);\n  }\n\n  get id(): string {\n    return this.clientId ?? this.apiBase;\n  }\n\n  constructor(host: string, clientId: string = ComfyApi.generateId()) {\n    super();\n    this.apiHost = host;\n    this.apiBase = host.split(\"://\")[1];\n    this.clientId = clientId;\n    return this;\n  }\n\n  private apiURL(route: string): string {\n    return `${this.apiHost}${route}`;\n  }\n\n  private async fetchApi(\n    route: string,\n    options?: FetchOptions\n  ): Promise<Response> {\n    if (!options) {\n      options = {};\n    }\n    if (!options.headers) {\n      options.headers = {};\n    }\n    options.headers[\"Comfy-User\"] = this.clientId || \"\";\n    return fetch(this.apiURL(route), options);\n  }\n\n  /**\n   * Polls the status for colab and other things that don't support websockets.\n   * @returns {Promise<QueueStatus>} The status information.\n   */\n  async pollStatus(): Promise<QueueStatus> {\n    const response = await this.fetchApi(\"/prompt\");\n    return response.json();\n  }\n\n  /**\n   * Queues a prompt for processing.\n   * @param {number} number The index at which to queue the prompt.\n   * @param {object} workflow Additional workflow data.\n   * @returns {Promise<QueuePromptResponse>} The response from the API.\n   */\n  async queuePrompt(\n    number: number,\n    workflow: object\n  ): Promise<QueuePromptResponse | false> {\n    const body = {\n      client_id: this.clientId,\n      prompt: workflow,\n    } as any;\n\n    if (number === -1) {\n      body[\"front\"] = true;\n    } else if (number !== 0) {\n      body[\"number\"] = number;\n    }\n\n    try {\n      const response = await this.fetchApi(\"/prompt\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body),\n      });\n\n      if (response.status !== 200) {\n        throw {\n          response: await response.json(),\n        };\n      }\n\n      return response.json();\n    } catch (e) {\n      console.warn(\"Can't queue prompt\", workflow, e);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves the current state of the queue.\n   * @returns {Promise<QueueResponse>} The queue state.\n   */\n  async getQueue(): Promise<QueueResponse> {\n    const response = await this.fetchApi(\"/queue\");\n    return response.json();\n  }\n\n  /**\n   * Retrieves the prompt execution history.\n   * @param {number} [maxItems=200] The maximum number of items to retrieve.\n   * @returns {Promise<HistoryResponse>} The prompt execution history.\n   */\n  async getHistories(maxItems: number = 200): Promise<HistoryResponse> {\n    const response = await this.fetchApi(`/history?max_items=${maxItems}`);\n    return response.json();\n  }\n\n  /**\n   * Retrieves the history entry for a given prompt ID.\n   * @param promptId - The ID of the prompt.\n   * @returns A Promise that resolves to the HistoryEntry object.\n   */\n  async getHistory(promptId: string): Promise<HistoryEntry | undefined> {\n    const response = await this.fetchApi(`/history/${promptId}`);\n    const history: HistoryResponse = await response.json();\n    return history[promptId];\n  }\n\n  /**\n   * Retrieves system and device stats.\n   * @returns {Promise<SystemStatsResponse>} The system stats.\n   */\n  async getSystemStats(): Promise<SystemStatsResponse> {\n    const response = await this.fetchApi(\"/system_stats\");\n    return response.json();\n  }\n\n  /**\n   * Retrieves a list of extension URLs.\n   * @returns {Promise<string[]>} A list of extension URLs.\n   */\n  async getExtensions(): Promise<string[]> {\n    const response = await this.fetchApi(\"/extensions\");\n    return response.json();\n  }\n\n  /**\n   * Retrieves a list of embedding names.\n   * @returns {Promise<string[]>} A list of embedding names.\n   */\n  async getEmbeddings(): Promise<string[]> {\n    const response = await this.fetchApi(\"/embeddings\");\n    return response.json();\n  }\n\n  /**\n   * Retrieves the checkpoints from the server.\n   * @returns A promise that resolves to an array of strings representing the checkpoints.\n   */\n  async getCheckpoints(): Promise<string[]> {\n    const nodeInfo = await this.getNodeDefs(LOAD_CHECKPOINTS_EXTENSION);\n    return (\n      nodeInfo[LOAD_CHECKPOINTS_EXTENSION].input.required?.ckpt_name?.[0] ?? []\n    );\n  }\n\n  /**\n   * Retrieves the Loras from the node definitions.\n   * @returns A Promise that resolves to an array of strings representing the Loras.\n   */\n  async getLoras(): Promise<string[]> {\n    const nodeInfo = await this.getNodeDefs(LOAD_LORAS_EXTENSION);\n    return nodeInfo[LOAD_LORAS_EXTENSION].input.required?.lora_name?.[0] ?? [];\n  }\n\n  /**\n   * Retrieves the sampler information.\n   * @returns An object containing the sampler and scheduler information.\n   */\n  async getSamplerInfo() {\n    const nodeInfo = await this.getNodeDefs(LOAD_KSAMPLER_EXTENSION);\n    return {\n      sampler:\n        nodeInfo[LOAD_KSAMPLER_EXTENSION].input.required.sampler_name ?? [],\n      scheduler:\n        nodeInfo[LOAD_KSAMPLER_EXTENSION].input.required.scheduler ?? [],\n    };\n  }\n\n  /**\n   * Retrieves node object definitions for the graph.\n   * @returns {Promise<NodeDefsResponse>} The node definitions.\n   */\n  async getNodeDefs(nodeName?: string): Promise<NodeDefsResponse> {\n    const response = await this.fetchApi(`/object_info/${nodeName ?? \"\"}`);\n    return response.json();\n  }\n\n  /**\n   * Retrieves user configuration data.\n   * @returns {Promise<any>} The user configuration data.\n   */\n  async getUserConfig(): Promise<any> {\n    const response = await this.fetchApi(\"/users\");\n    return response.json();\n  }\n\n  /**\n   * Creates a new user.\n   * @param {string} username The username of the new user.\n   * @returns {Promise<Response>} The response from the API.\n   */\n  async createUser(username: string): Promise<Response> {\n    const response = await this.fetchApi(\"/users\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ username }),\n    });\n    return response;\n  }\n\n  /**\n   * Retrieves all setting values for the current user.\n   * @returns {Promise<any>} A dictionary of setting id to value.\n   */\n  async getSettings(): Promise<any> {\n    const response = await this.fetchApi(\"/settings\");\n    return response.json();\n  }\n\n  /**\n   * Retrieves a specific setting for the current user.\n   * @param {string} id The id of the setting to fetch.\n   * @returns {Promise<any>} The setting value.\n   */\n  async getSetting(id: string): Promise<any> {\n    const response = await this.fetchApi(`/settings/${encodeURIComponent(id)}`);\n    return response.json();\n  }\n\n  /**\n   * Stores a dictionary of settings for the current user.\n   * @param {Record<string, unknown>} settings Dictionary of setting id to value to save.\n   * @returns {Promise<void>}\n   */\n  async storeSettings(settings: Record<string, unknown>): Promise<void> {\n    await this.fetchApi(`/settings`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(settings),\n    });\n  }\n\n  /**\n   * Stores a specific setting for the current user.\n   * @param {string} id The id of the setting to update.\n   * @param {unknown} value The value of the setting.\n   * @returns {Promise<void>}\n   */\n  async storeSetting(id: string, value: unknown): Promise<void> {\n    await this.fetchApi(`/settings/${encodeURIComponent(id)}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(value),\n    });\n  }\n\n  /**\n   * Uploads an image file to the server.\n   * @param file - The image file to upload.\n   * @param fileName - The name of the image file.\n   * @param override - Optional. Specifies whether to override an existing file with the same name. Default is true.\n   * @returns A Promise that resolves to an object containing the image information and the URL of the uploaded image,\n   *          or false if the upload fails.\n   */\n  async uploadImage(\n    file: Buffer | Blob,\n    fileName: string,\n    config?: {\n      override?: boolean;\n      subfolder?: string;\n    }\n  ): Promise<{ info: ImageInfo; url: string } | false> {\n    const formData = new FormData();\n    if (file instanceof Buffer) {\n      formData.append(\"image\", new Blob([file]), fileName);\n    } else {\n      formData.append(\"image\", file, fileName);\n    }\n    formData.append(\"subfolder\", config?.subfolder ?? \"\");\n    formData.append(\"overwrite\", config?.override?.toString() ?? \"false\");\n\n    try {\n      const response = await this.fetchApi(\"/upload/image\", {\n        method: \"POST\",\n        body: formData,\n      });\n      const imgInfo = await response.json();\n      const mapped = { ...imgInfo, filename: imgInfo.name };\n      return {\n        info: mapped,\n        url: this.getPathImage(mapped),\n      };\n    } catch (e) {\n      console.warn(e);\n      return false;\n    }\n  }\n\n  /**\n   * Returns the path to an image based on the provided image information.\n   * @param imageInfo - The information of the image.\n   * @returns The path to the image.\n   */\n  getPathImage(imageInfo: ImageInfo): string {\n    return this.apiURL(\n      `/view?filename=${imageInfo.filename}&type=${imageInfo.type}&subfolder=${\n        imageInfo.subfolder ?? \"\"\n      }`\n    );\n  }\n\n  /**\n   * Retrieves a user data file for the current user.\n   * @param {string} file The name of the userdata file to load.\n   * @returns {Promise<Response>} The fetch response object.\n   */\n  async getUserData(file: string): Promise<Response> {\n    return this.fetchApi(`/userdata/${encodeURIComponent(file)}`);\n  }\n\n  /**\n   * Stores a user data file for the current user.\n   * @param {string} file The name of the userdata file to save.\n   * @param {unknown} data The data to save to the file.\n   * @param {RequestInit & { overwrite?: boolean, stringify?: boolean, throwOnError?: boolean }} [options] Additional options for storing the file.\n   * @returns {Promise<Response>}\n   */\n  async storeUserData(\n    file: string,\n    data: unknown,\n    options: RequestInit & {\n      overwrite?: boolean;\n      stringify?: boolean;\n      throwOnError?: boolean;\n    } = { overwrite: true, stringify: true, throwOnError: true }\n  ): Promise<Response> {\n    const response = await this.fetchApi(\n      `/userdata/${encodeURIComponent(file)}?overwrite=${options.overwrite}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": options.stringify\n            ? \"application/json\"\n            : \"application/octet-stream\",\n        } as any,\n        body: options.stringify ? JSON.stringify(data) : (data as any),\n        ...options,\n      }\n    );\n\n    if (response.status !== 200 && options.throwOnError !== false) {\n      throw new Error(\n        `Error storing user data file '${file}': ${response.status} ${response.statusText}`\n      );\n    }\n\n    return response;\n  }\n\n  /**\n   * Deletes a user data file for the current user.\n   * @param {string} file The name of the userdata file to delete.\n   * @returns {Promise<void>}\n   */\n  async deleteUserData(file: string): Promise<void> {\n    const response = await this.fetchApi(\n      `/userdata/${encodeURIComponent(file)}`,\n      {\n        method: \"DELETE\",\n      }\n    );\n\n    if (response.status !== 204) {\n      throw new Error(\n        `Error removing user data file '${file}': ${response.status} ${response.statusText}`\n      );\n    }\n  }\n\n  /**\n   * Moves a user data file for the current user.\n   * @param {string} source The userdata file to move.\n   * @param {string} dest The destination for the file.\n   * @param {RequestInit & { overwrite?: boolean }} [options] Additional options for moving the file.\n   * @returns {Promise<Response>}\n   */\n  async moveUserData(\n    source: string,\n    dest: string,\n    options: RequestInit & { overwrite?: boolean } = { overwrite: false }\n  ): Promise<Response> {\n    return this.fetchApi(\n      `/userdata/${encodeURIComponent(source)}/move/${encodeURIComponent(\n        dest\n      )}?overwrite=${options.overwrite}`,\n      {\n        method: \"POST\",\n      }\n    );\n  }\n\n  /**\n   * Lists user data files for the current user.\n   * @param {string} dir The directory in which to list files.\n   * @param {boolean} [recurse] If the listing should be recursive.\n   * @param {boolean} [split] If the paths should be split based on the OS path separator.\n   * @returns {Promise<string[]>} The list of files.\n   */\n  async listUserData(\n    dir: string,\n    recurse?: boolean,\n    split?: boolean\n  ): Promise<string[]> {\n    const response = await this.fetchApi(\n      `/userdata?${new URLSearchParams({\n        dir,\n        recurse: recurse?.toString() ?? \"\",\n        split: split?.toString() ?? \"\",\n      })}`\n    );\n\n    if (response.status === 404) return [];\n    if (response.status !== 200) {\n      throw new Error(\n        `Error getting user data list '${dir}': ${response.status} ${response.statusText}`\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Interrupts the execution of the running prompt.\n   * @returns {Promise<void>}\n   */\n  async interrupt(): Promise<void> {\n    await this.fetchApi(\"/interrupt\", {\n      method: \"POST\",\n    });\n  }\n\n  /**\n   * Initializes the WebSocket for real-time updates.\n   */\n  init() {\n    this.createSocket();\n    return this;\n  }\n\n  /**\n   * Creates and connects a WebSocket for real-time updates.\n   * @param {boolean} isReconnect If the socket connection is a reconnect attempt.\n   */\n  private createSocket(isReconnect: boolean = false) {\n    if (this.socket) {\n      return;\n    }\n\n    let opened = false;\n    let existingSession = \"?clientId=\" + this.clientId;\n    this.socket = new WebSocket(\n      `ws${this.apiHost.includes(\"https:\") ? \"s\" : \"\"}://${\n        this.apiBase\n      }/ws${existingSession}`\n    );\n    this.socket.binaryType = \"arraybuffer\";\n\n    this.socket.addEventListener(\"open\", () => {\n      opened = true;\n      if (isReconnect) {\n        this.dispatchEvent(new CustomEvent(\"reconnected\"));\n      }\n    });\n\n    this.socket.addEventListener(\"error\", () => {\n      if (this.socket) this.socket.close();\n      if (!isReconnect && !opened) {\n        this.pollQueue();\n      }\n    });\n\n    this.socket.addEventListener(\"close\", () => {\n      setTimeout(() => {\n        this.socket = null;\n        this.createSocket(true);\n      }, 300);\n      if (opened) {\n        this.dispatchEvent(new CustomEvent(\"status\", { detail: null }));\n        this.dispatchEvent(new CustomEvent(\"reconnecting\"));\n      }\n    });\n\n    this.socket.addEventListener(\"message\", (event) => {\n      try {\n        if (event.data instanceof ArrayBuffer) {\n          const view = new DataView(event.data);\n          const eventType = view.getUint32(0);\n          const buffer = event.data.slice(4);\n          switch (eventType) {\n            case 1:\n              const view2 = new DataView(event.data);\n              const imageType = view2.getUint32(0);\n              let imageMime;\n              switch (imageType) {\n                case 1:\n                default:\n                  imageMime = \"image/jpeg\";\n                  break;\n                case 2:\n                  imageMime = \"image/png\";\n              }\n              const imageBlob = new Blob([buffer.slice(4)], {\n                type: imageMime,\n              });\n              this.dispatchEvent(\n                new CustomEvent(\"b_preview\", { detail: imageBlob })\n              );\n              break;\n            default:\n              throw new Error(\n                `Unknown binary websocket message of type ${eventType}`\n              );\n          }\n        } else {\n          const msg = JSON.parse(event.data);\n          if (msg.type !== \"crystools.monitor\") {\n            this.dispatchEvent(new CustomEvent(\"all\", { detail: msg }));\n          }\n          switch (msg.type) {\n            case \"status\":\n              if (msg.data.sid) {\n                this.clientId = msg.data.sid;\n              }\n              this.dispatchEvent(\n                new CustomEvent(\"status\", { detail: msg.data.status })\n              );\n              break;\n            case \"progress\":\n              this.dispatchEvent(\n                new CustomEvent(\"progress\", { detail: msg.data })\n              );\n              break;\n            case \"executing\":\n              this.dispatchEvent(\n                new CustomEvent(\"executing\", { detail: msg.data.node })\n              );\n              break;\n            case \"executed\":\n              this.dispatchEvent(\n                new CustomEvent(\"executed\", { detail: msg.data })\n              );\n              break;\n            case \"execution_start\":\n              this.dispatchEvent(\n                new CustomEvent(\"execution_start\", { detail: msg.data })\n              );\n              break;\n            case \"execution_error\":\n              this.dispatchEvent(\n                new CustomEvent(\"execution_error\", { detail: msg.data })\n              );\n              break;\n            case \"execution_cached\":\n              this.dispatchEvent(\n                new CustomEvent(\"execution_cached\", { detail: msg.data })\n              );\n              break;\n            case \"crystools.monitor\":\n              this.dispatchEvent(\n                new CustomEvent(\"crystools.monitor\", { detail: msg.data })\n              );\n              break;\n            default:\n              if (this.registered.has(msg.type)) {\n                this.dispatchEvent(\n                  new CustomEvent(msg.type, { detail: msg.data })\n                );\n              } else {\n                console.warn(\"Unhandled event from server\", msg.type, msg.data);\n              }\n          }\n        }\n      } catch (error) {\n        console.warn(\"Unhandled message:\", event.data, error);\n      }\n    });\n  }\n\n  /**\n   * Polls the status queue for updates.\n   * Used for environments that do not support WebSockets.\n   */\n  private pollQueue() {\n    setInterval(async () => {\n      try {\n        const response = await this.fetchApi(\"/prompt\");\n        const status = await response.json();\n        this.dispatchEvent(new CustomEvent(\"status\", { detail: status }));\n      } catch (error) {\n        this.dispatchEvent(new CustomEvent(\"status\", { detail: null }));\n      }\n    }, 1000);\n  }\n}\n",
    "import type { NodeProgress } from \"../types/api\";\nimport type { ComfyApi } from \"./client\";\nimport type { PromptCaller } from \"./prompt-builder\";\n\nexport class CallWrapper<T extends PromptCaller<string, string>> {\n  private client: ComfyApi;\n  private prompt: T;\n  private started = false;\n\n  private onPreviewFn?: (ev: Blob) => void;\n  private onStartFn?: () => void;\n  private onFinishedFn?: (data: Record<keyof T[\"mapOutputPath\"], any>) => void;\n  private onFailedFn?: () => void;\n  private onProgressFn?: (info: NodeProgress) => void;\n\n  constructor(client: ComfyApi, workflow: T) {\n    this.client = client;\n    this.prompt = workflow;\n    return this;\n  }\n\n  onPreview(fn: (ev: Blob) => void) {\n    this.onPreviewFn = fn;\n    return this;\n  }\n\n  onStart(fn: () => void) {\n    this.onStartFn = fn;\n    return this;\n  }\n\n  onFinished(fn: (data: Record<keyof T[\"mapOutputPath\"], any>) => void) {\n    this.onFinishedFn = fn;\n    return this;\n  }\n\n  onFailed(fn: () => void) {\n    this.onFailedFn = fn;\n    return this;\n  }\n\n  onProgress(fn: (info: NodeProgress) => void) {\n    this.onProgressFn = fn;\n    return this;\n  }\n\n  async run(): Promise<\n    Record<keyof T[\"mapOutputPath\"], any> | undefined | false\n  > {\n    const job = await this.client.queuePrompt(-1, this.prompt.workflow);\n    if (job) {\n      const outputMapped = this.prompt.mapOutputKeys;\n      const reverseOutputMapped = Object.entries(outputMapped).reduce(\n        (acc, [k, v]) => {\n          if (v) {\n            acc[v] = k;\n          }\n          return acc;\n        },\n        {} as Record<string, string>\n      );\n      const { prompt_id } = job;\n      const output: Record<keyof T[\"mapOutputPath\"], any> = {} as any;\n\n      // Try to get history if it's already cached\n      const hisData = await this.client.getHistory(prompt_id);\n      if (hisData?.status?.completed) {\n        const outputNodes = hisData.outputs;\n        for (const key in outputMapped) {\n          const node = outputMapped[key];\n          if (node) {\n            output[key as keyof T[\"mapOutputPath\"]] = outputNodes[node];\n          }\n        }\n        this.onFinishedFn?.(output);\n        return output;\n      }\n\n      const executingFn = (ev: CustomEvent) => {\n        if (ev.detail.prompt_id === prompt_id && !this.started) {\n          this.started = true;\n          this.onStartFn?.();\n        }\n        this.onProgressFn?.(ev.detail);\n      };\n      const previewFn = (ev: CustomEvent<Blob>) => {\n        if (this.onPreviewFn) {\n          this.onPreviewFn(ev.detail);\n        }\n      };\n\n      this.client.on(\"progress\", executingFn);\n      this.client.on(\"b_preview\", previewFn);\n\n      let totalOutput = Object.keys(reverseOutputMapped).length;\n      return new Promise<Record<keyof T[\"mapOutputPath\"], any> | false>(\n        (resolve) => {\n          const fn = (ev: CustomEvent) => {\n            const data = ev.detail;\n            if (data.prompt_id !== prompt_id) return;\n            const node = data.node as keyof typeof this.prompt.mapOutputPath;\n            if (reverseOutputMapped[node]) {\n              const outputKey = reverseOutputMapped[node];\n              if (outputKey) {\n                output[outputKey as keyof T[\"mapOutputPath\"]] = data.output;\n              }\n              totalOutput--;\n            }\n            if (totalOutput === 0) {\n              this.client.off(\"progress\", executingFn);\n              this.client.off(\"executed\", fn);\n              this.client.off(\"b_preview\", previewFn);\n              this.onFinishedFn?.(output);\n              resolve(output);\n            }\n          };\n          this.client.on(\"executed\", fn);\n\n          // Failed FN\n          const failedFn = (ev: CustomEvent) => {\n            if (ev.detail.prompt_id !== prompt_id) return;\n            this.client.off(\"progress\", executingFn);\n            this.client.off(\"executed\", fn);\n            this.client.off(\"b_preview\", previewFn);\n            this.client.off(\"execution_error\", failedFn);\n            this.onFailedFn?.();\n            resolve(false);\n          };\n          this.client.on(\"execution_error\", failedFn);\n        }\n      );\n    }\n  }\n}\n",
    "export const delay = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n",
    "import type { ComfyApi } from \"./client\";\nimport { delay } from \"./tools\";\n\n/**\n * Represents the mode for picking clients from a queue.\n *\n * - \"PICK_ZERO\": Picks the client which has zero queue remaining. This is the default mode. (For who using along with ComfyUI web interface)\n * - \"PICK_LOWEST\": Picks the client which has the lowest queue remaining.\n * - \"PICK_ROUTINE\": Picks the client in a round-robin manner.\n */\nexport enum EQueueMode {\n  /**\n   * Picks the client which has zero queue remaining. This is the default mode. (For who using along with ComfyUI web interface)\n   */\n  \"PICK_ZERO\",\n  /**\n   * Picks the client which has the lowest queue remaining.\n   */\n  \"PICK_LOWEST\",\n  /**\n   * Picks the client in a round-robin manner.\n   */\n  \"PICK_ROUTINE\",\n}\n\nexport class ComfyPool {\n  clients: ComfyApi[];\n  queueInfo: number[] = [];\n  pickingInfo: boolean[] = [];\n  mode: EQueueMode = EQueueMode.PICK_ZERO;\n\n  jobQueue: ((api: ComfyApi) => Promise<void>)[] = [];\n\n  /**\n   * This is for PICK_ROUTINE mode\n   */\n  routineIdx: number = 0;\n\n  picking = false;\n\n  /**\n   * Represents a pool of ComfyApi clients.\n   * @param clients - An array of ComfyApi instances.\n   * @param mode - The queue mode for the pool. Defaults to \"PICK_ZERO\".\n   */\n  constructor(clients: ComfyApi[], mode: EQueueMode = EQueueMode.PICK_ZERO) {\n    this.clients = clients;\n    for (let i = 0; i < clients.length; i++) {\n      this.queueInfo.push(0);\n      this.pickingInfo.push(false);\n      this.clients[i].on(\"status\", (ev) => {\n        this.queueInfo[i] = ev.detail.exec_info.queue_remaining as number;\n        if (this.queueInfo[i] > 0) {\n          this.pickingInfo[i] = false;\n        }\n      });\n      this.clients[i].init();\n    }\n    this.mode = mode;\n    return this;\n  }\n\n  addClient(client: ComfyApi) {\n    this.clients.push(client);\n    this.queueInfo.push(0);\n    const index = this.clients.length - 1;\n    this.clients[index].on(\"status\", (ev) => {\n      this.queueInfo[index] = ev.detail.exec_info.queue_remaining as number;\n    });\n  }\n\n  removeClient(client: ComfyApi) {\n    const index = this.clients.indexOf(client);\n    if (index !== -1) {\n      this.clients.splice(index, 1);\n      this.queueInfo.splice(index, 1);\n    }\n  }\n\n  private claim(fn: (client: ComfyApi) => Promise<void>) {\n    this.jobQueue.push(fn);\n    this.pickJob();\n  }\n\n  /**\n   * Run a task on the pool.\n   */\n  run<T>(claim: (client: ComfyApi) => Promise<T>) {\n    return new Promise<T>((resolve, reject) => {\n      this.claim(async (client) => {\n        try {\n          resolve(await claim(client));\n        } catch (e) {\n          console.error(e);\n          reject(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Run a batch of tasks on the pool.\n   */\n  batch<T>(claims: ((client: ComfyApi) => Promise<T>)[]) {\n    const promises = claims.map((task) => {\n      return this.run(task);\n    });\n    return Promise.all(promises);\n  }\n\n  private async getAvailableClient() {\n    switch (this.mode) {\n      case EQueueMode.PICK_ZERO: {\n        let found = -1;\n        while (found === -1) {\n          found = this.queueInfo.findIndex((crr, idx) => {\n            if (crr === 0 && !this.pickingInfo[idx]) return true;\n            return false;\n          });\n          if (found === -1) {\n            await delay(50);\n          }\n        }\n        this.queueInfo[found] = 1;\n        this.pickingInfo[found] = true;\n        return this.clients[found];\n      }\n      case EQueueMode.PICK_LOWEST: {\n        // Pick lowest queue remaining\n        let found = -1;\n        let min = Number.MAX_SAFE_INTEGER;\n        for (let i = 0; i < this.queueInfo.length; i++) {\n          if (this.queueInfo[i] < min) {\n            min = this.queueInfo[i];\n            found = i;\n          }\n        }\n        this.queueInfo[found] = +1;\n        return this.clients[found];\n      }\n      case EQueueMode.PICK_ROUTINE: {\n        const found = this.routineIdx;\n        this.routineIdx = (this.routineIdx + 1) % this.clients.length;\n        return this.clients[found];\n      }\n    }\n  }\n\n  private async pickJob() {\n    if (this.picking) return;\n    if (this.jobQueue.length === 0) return;\n    const job = this.jobQueue.shift();\n    this.picking = true;\n    const client = await this.getAvailableClient();\n    job?.(client);\n    this.picking = false;\n    this.pickJob();\n  }\n}\n",
    "import type { KeysUnion } from \"../types/tool\";\n\nexport class PromptCaller<I extends string = \"\", O extends string = \"\"> {\n  prompt: object;\n  mapInputPath: Record<I, string | undefined>;\n  mapOutputPath: Record<O, string | undefined>;\n\n  constructor(\n    prompt: object,\n    mapIn: Record<string, string | undefined>,\n    mapOut: Record<string, string | undefined>\n  ) {\n    this.prompt = JSON.parse(JSON.stringify(prompt));\n    this.mapInputPath = mapIn;\n    this.mapOutputPath = mapOut;\n    return this;\n  }\n\n  input<T = string | number>(key: I, value: T) {\n    const path = this.mapInputPath[key] as string;\n    if (!path) {\n      throw new Error(`Key ${key} not found`);\n    }\n    const keys = path.split(\".\");\n    let current = this.prompt as any;\n    for (let i = 0; i < keys.length - 1; i++) {\n      current = current[keys[i]];\n    }\n    current[keys[keys.length - 1]] = value;\n    return this;\n  }\n\n  get mapOutputKeys(): Record<O, string | undefined> {\n    return this.mapOutputPath;\n  }\n\n  get mapInputKeys() {\n    return this.mapOutputPath;\n  }\n\n  get workflow() {\n    return this.prompt;\n  }\n}\n\nexport class PromptBuilder<I extends string, O extends string, T = object> {\n  prompt: T;\n  mapInputKeys: Record<I, KeysUnion<T> | undefined> = {} as any;\n  mapOutputKeys: Record<O, KeysUnion<T> | undefined> = {} as any;\n\n  constructor(prompt: T, inputKeys: I[], outputKeys: O[]) {\n    this.prompt = prompt;\n    inputKeys.forEach((key) => {\n      this.mapInputKeys[key] = undefined;\n    });\n    outputKeys.forEach((key) => {\n      this.mapOutputKeys[key] = undefined;\n    });\n    return this;\n  }\n\n  setInputNode(input: I, key: KeysUnion<T>) {\n    this.mapInputKeys[input] = key;\n    return this;\n  }\n\n  setOutputNode(output: O, key: KeysUnion<T>) {\n    this.mapOutputKeys[output] = key;\n    return this;\n  }\n\n  get caller() {\n    return new PromptCaller<I, O>(\n      this.prompt as object,\n      this.mapInputKeys,\n      this.mapOutputKeys\n    );\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "9BB9C064189B9A9864756E2164756E21",
  "names": []
}